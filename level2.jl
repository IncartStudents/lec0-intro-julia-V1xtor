# выболнить большую часть заданий ниже:

"""
======================================================================
1. Система типов: приведение к типам,
конкретные и абстрактные типы,
множественная диспетчеризация
"""

"""
что происходит с типами, какого типа `c` и почему? 
"""
#%%
a = 1  # int64
b = 2.0  # float64
c = a + b  # float64
typeof(c)
#%%
"""
c — float, потому что если например b=2.1, а не 2.0, то c=3.1, что не может быть типом int64
"""

"""
написать тип, параметризованный другим типом
"""

"""
написать функцию для двух аругментов, не указывая их тип,
и вторую функцию от двух аргментов с конкретными типами,
дать пример запуска
"""
function f(x, y)
    x+y
end

function f(x::String, y::Float64)
    println("qqwer $x and $y")
end

f(1,2)
f("asdf", 4.0)

"""
абстрактный тип - ключевое слово? abstract
примитивный тип - ключевое слово? primitive
композитный тип - ключевое слово? struct or mutable struct
"""

"""
написать один абстрактный тип и два его подтипа (1 и 2)
написать функцию над абстрактным типом, и функцию над её подтипом-1
выполнить функции над объектами подтипов 1 и 2 и объяснить результат
(функция выводит произвольный текст в консоль)
"""
abstract type NDimPoint end
struct Point1<:NDimPoint
    x1::Float64
end

struct Point2<:NDimPoint
    x1::Float64
    x2::Float64
end
x = Point1(2.3)
vec2 = Point2(3.5, 6.1)

function barz(p::NDimPoint)
    println("qwer $p asdf")
end

barz(x)
barz(vec2)


"""
======================================================================
2. Функции:
лямбды и обычные функции,
переменное количество аргументов,
именованные аргументы со значениями по умолчанию,
кортежи
"""

"""
пример обычной функции
"""

"""
пример лямбда-функции (аннонимной функции)
"""

"""
пример функции с переменным количеством аргументов
"""

"""
пример функции с именованными аргументами
"""

"""
функции с переменным кол-вом именованных аргументов
"""

"""
передать кортеж в функцию, которая принимает на вход несколько аргументов
присвоить кортеж результату функции, которая возвращает несколько аргументов
использовать splatting - деструктуризацию кортежа в набор аргументов
"""

"""
======================================================================
3. loop fusion, broadcast, filter, map, reduce
"""

"""
перемножить все элементы массива
с помощью reduce
"""

"""
написать функцию от одного аргумента и запустить ее по всем элементам массива
с помощью точки (broadcast)
c помощью map
указать, чем это лучше явного цикла?
"""

"""
перемножить вектор-строку [1 2 3] на вектор-столбец [10,20,30] и объяснить результат
"""

"""
в одну строку выбрать из массива [1, -2, 2, 3, 4, -5, 0] только четные и положительные числа
"""


"""
======================================================================
4. Свой тип данных на общих интерфейсах
"""

"""
написать свой тип ленивого массива, каждый элемент которого
вычисляется при взятии индекса (getindex) по формуле (index - 1)^2
"""

"""
Написать два типа объектов команд, унаследованных от AbstractCommand,
которые применяются к массиву:
`SortCmd()` - сортирует исходный массив
`ChangeAtCmd(i, val)` - меняет элемент на позиции i на значение val
Каждая команда имеет конструктор и реализацию метода apply!
"""
abstract type AbstractCommand end
apply!(cmd::AbstractCommand, target::Vector) = error("Not implemented for type $(typeof(cmd))")


"""
Аналогичные команды, но без наследования и в виде замыканий (лямбда-функций)
"""

"""
======================================================================
5. Тесты: как проверять функции?
"""

"""
написать тест для функции
"""

"""
======================================================================
6. Дебаг: как отладить функцию по шагам?
"""

"""
написать и отладить функцию по шагам с помощью макроса @enter и точек останова
"""

"""
======================================================================
7. Профилировщик: как оценить производительность функции?

"""

"""
оценить производительность функции с помощью макроса @profview
"""
function generate_data(len)
    vec1 = Any[]
    for k = 1:len
        r = randn(1,1)
        append!(vec1, r)
    end
    vec2 = sort(vec1)
    vec3 = vec2 .^ 3 .- (sum(vec2) / len)
    return vec3
end

@time generate_data(1_000_000);

"""
предложить, как переписать функцию так, чтобы она выполнялась быстрее?
"""

"""
======================================================================
8. Отличия от матлаба: приращение массива и предварительная аллокация?
"""

"""
написать функцию определения первой разности, которая принимает и возвращает массив
и для каждой точки входного (x) и выходного (y) выходного массива вычисляет:
y[i] = x[i] - x[i-1]
"""

"""
аналогичная функция, которая отличается тем, что внутри себя не аллоцирует новый массив y,
а принимает его первым аргументом, сам массив аллоцируется до вызова функции
"""

"""
написать код, который добавляет элементы в конец массива, в начало массива,
в середину массива
"""

"""
======================================================================
9. Модули и функции: как оборачивать функции внутрь модуля, как их экспортировать
и пользоваться вне модуля?
"""


"""
написать модуль с двумя функциями,
экспортировать одну из них,
воспользоваться обеими функциями вне модуля
"""
module Foo
    #export ?
end
# using .Foo ?
# import .Foo ?

"""
======================================================================
10. Зависимости, окружение и пакеты
"""

"""
что такое environment, как задать его, как его поменять во время работы?
"""

"""
что такое пакет (package), как добавить новый пакет?
"""

"""
как начать разрабатывать чужой пакет?
"""

"""
как создать свой пакет? (сложный вопрос, поэтому необязательно)
"""

"""
======================================================================
11. Аргументы запуска Julia
"""

"""
Как задать окружение при запуске?
"""

"""
Как задать скрипт, который будет выполняться при запуске:
а) из файла .jl
б) из текста команды? (см. флаг -e)
"""
